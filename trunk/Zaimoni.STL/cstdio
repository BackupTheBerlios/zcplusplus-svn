// cstdio
// header for file convenience functions
// (C)2009 Kenneth Boyd, license: MIT.txt

#ifndef ZAIMONI_CSTDIO
#define ZAIMONI_CSTDIO 1

#include "Logging.h"
#include "MetaRAM.hpp"
#include <cstdio>

#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
#include <io.h>
#endif

namespace zaimoni {

template<class T>
inline typename boost::enable_if<boost::has_trivial_assign<T>, void>::type
#ifndef ZAIMONI_FORCE_ISO
ConvertBinaryModeToTextMode(T*& Buffer)
#else
ConvertBinaryModeToTextMode(T*& Buffer, size_t& BufferLen)
#endif
{	//! \todo VERIFY
	if (NULL!=Buffer)
		{
#ifndef ZAIMONI_FORCE_ISO 
		const size_t BufferLen = ArraySize(Buffer);
#else
		assert(0<BufferLen);
#endif
		size_t Displace = 0;
		size_t ScanIdx = 0;
		do	if ('\r'==Buffer[ScanIdx])
				{	// oops.  We're either Windows ['\r\n'] or wrong-platform ['\r': UNIX on Mac, or Mac on Unix; '\n\r': Windows on UNIX]
				const bool WindowsOnMac = (1<=ScanIdx && '\n'==Buffer[ScanIdx-1]);
				const bool Windows = BufferLen>ScanIdx+1 && '\n'==Buffer[ScanIdx+1];
				const bool WrongPlatform = !WindowsOnMac && !Windows;	// no problem if both
				if (WrongPlatform)
					Buffer[ScanIdx]='\n';
				else{
					if (BufferLen>(ScanIdx+1)) memmove(&Buffer[ScanIdx],&Buffer[ScanIdx+1],sizeof(char)*(BufferLen-(ScanIdx+1)));
					++Displace;
					}
				}
		while(BufferLen-Displace>++ScanIdx);
		if (0<Displace)
#ifndef ZAIMONI_FORCE_ISO
			Buffer = zaimoni::REALLOC(Buffer,_msize(Buffer)-Displace*sizeof(char));
#else
			Buffer = zaimoni::REALLOC(Buffer,sizeof(char)*(BufferLen -= Displace));
#endif
		}
}

template<class T>
inline typename boost::enable_if<boost::has_trivial_assign<T>, bool>::type
#ifndef ZAIMONI_FORCE_ISO
GetBinaryFileImage(const char* const Filename,T*& Buffer)
#else
GetBinaryFileImage(const char* const Filename,T*& Buffer,size_t& Buffer_size)
#endif
{	// FORMALLY CORRECT: Kenneth Boyd, 11/10/2004
	assert(NULL!=Filename);
	assert(NULL==Buffer);
#ifdef ZAIMONI_FORCE_ISO
	assert(0==Buffer_size);
#endif

	FILE* TargetFile = fopen(Filename, "rb");
	if (NULL==TargetFile) return false;

	// Want to know the file length *BEFORE* inhaling it
#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
	long ScriptLength = _filelength(_fileno(TargetFile));
	if (-1==ScriptLength)	/* XXX required by secure coding standards XXX */
	{
		fclose(TargetFile);
		return false;
	}
#else
	// Failing over to implementation-defined extension of ISO C.
	if (fseek(TargetFile,0,SEEK_END))	// ISO does not guarantee this works.
	{
		fclose(TargetFile);
		return false;
	};
	long ScriptLength = ftell(TargetFile);
	if (-1==ScriptLength)	/* XXX required by secure coding standards XXX */
	{
		fclose(TargetFile);
		return false;
	}
	rewind(TargetFile);
#endif

	assert(0==ScriptLength%sizeof(T));
	size_t ActuallyRead = 0;
	if (0<ScriptLength)
	{
		Buffer = REALLOC(Buffer,ScriptLength);
#ifdef ZAIMONI_FORCE_ISO
		Buffer_size = ScriptLength;
#endif
		ActuallyRead = fread(Buffer,sizeof(T),ScriptLength/sizeof(T),TargetFile);
	}

	fclose(TargetFile);
	return ActuallyRead==ScriptLength/sizeof(T);
}

template<class T>
inline typename boost::enable_if<boost::has_trivial_assign<T>, bool>::type
SaveBinaryFileImage(const char* const Filename,const T* const Buffer,size_t BufferLength)
{	// FORMALLY CORRECT: Kenneth Boyd, 1/14/2007
	assert(NULL!=Filename);
	assert(NULL!=Buffer);
	assert(0!=BufferLength);

	FILE* TargetFile = fopen(Filename, "wb");
	if (NULL==TargetFile) return false;
	size_t ActualWrite = fwrite(Buffer,sizeof(T),BufferLength,TargetFile);
	fclose(TargetFile);
	return ActualWrite==BufferLength;
}

}	// end namespace zaimoni

#endif
